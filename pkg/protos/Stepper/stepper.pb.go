// Code generated by protoc-gen-go. DO NOT EDIT.
// source: Stepper/stepper.proto

package stepper

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Define the various simulated time stepping policies
type StepperPolicy int32

const (
	// Default value, indicates an uninitialized stepper
	StepperPolicy_Invalid StepperPolicy = 0
	// Policy that immediately moves the simulated time forward with any
	// wait operation.  Useful for shortening test runs.
	StepperPolicy_NoWait StepperPolicy = 1
	// Policy that magnifies time, but still proceeds forward automatically.
	// This option requires a delay per tick to determine how fast time runs
	StepperPolicy_Measured StepperPolicy = 2
	// Policy that requires manual stepping of time.  Simulated time only
	// moves forward as a result of an externally generated step command.
	StepperPolicy_Manual StepperPolicy = 3
)

var StepperPolicy_name = map[int32]string{
	0: "Invalid",
	1: "NoWait",
	2: "Measured",
	3: "Manual",
}

var StepperPolicy_value = map[string]int32{
	"Invalid":  0,
	"NoWait":   1,
	"Measured": 2,
	"Manual":   3,
}

func (x StepperPolicy) String() string {
	return proto.EnumName(StepperPolicy_name, int32(x))
}

func (StepperPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a47a4dd6ded36602, []int{0}
}

// Define the parameters to a stepper policy request parameters
type PolicyRequest struct {
	// Required policy
	Policy StepperPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=stepper.StepperPolicy" json:"policy,omitempty"`
	// Number of seconds between ticks.  Only valid for the "Measured" policy.
	MeasuredDelay        *duration.Duration `protobuf:"bytes,2,opt,name=measuredDelay,proto3" json:"measuredDelay,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *PolicyRequest) Reset()         { *m = PolicyRequest{} }
func (m *PolicyRequest) String() string { return proto.CompactTextString(m) }
func (*PolicyRequest) ProtoMessage()    {}
func (*PolicyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a47a4dd6ded36602, []int{0}
}

func (m *PolicyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PolicyRequest.Unmarshal(m, b)
}
func (m *PolicyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PolicyRequest.Marshal(b, m, deterministic)
}
func (m *PolicyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PolicyRequest.Merge(m, src)
}
func (m *PolicyRequest) XXX_Size() int {
	return xxx_messageInfo_PolicyRequest.Size(m)
}
func (m *PolicyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PolicyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PolicyRequest proto.InternalMessageInfo

func (m *PolicyRequest) GetPolicy() StepperPolicy {
	if m != nil {
		return m.Policy
	}
	return StepperPolicy_Invalid
}

func (m *PolicyRequest) GetMeasuredDelay() *duration.Duration {
	if m != nil {
		return m.MeasuredDelay
	}
	return nil
}

// Define the parameters when requesting a delay
type DelayRequest struct {
	// The minimum simulated time before the delay is completed.
	AtLeast int64 `protobuf:"varint,1,opt,name=atLeast,proto3" json:"atLeast,omitempty"`
	// An additional maximum number of ticks that can be added to the delay.
	// A random number of ticks [0-jitter) are added to the delay time.  This
	// is to simulate the random delays seen in, e.g., disk I/O or network
	// communications.
	Jitter               int64    `protobuf:"varint,2,opt,name=jitter,proto3" json:"jitter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DelayRequest) Reset()         { *m = DelayRequest{} }
func (m *DelayRequest) String() string { return proto.CompactTextString(m) }
func (*DelayRequest) ProtoMessage()    {}
func (*DelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a47a4dd6ded36602, []int{1}
}

func (m *DelayRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DelayRequest.Unmarshal(m, b)
}
func (m *DelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DelayRequest.Marshal(b, m, deterministic)
}
func (m *DelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelayRequest.Merge(m, src)
}
func (m *DelayRequest) XXX_Size() int {
	return xxx_messageInfo_DelayRequest.Size(m)
}
func (m *DelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DelayRequest proto.InternalMessageInfo

func (m *DelayRequest) GetAtLeast() int64 {
	if m != nil {
		return m.AtLeast
	}
	return 0
}

func (m *DelayRequest) GetJitter() int64 {
	if m != nil {
		return m.Jitter
	}
	return 0
}

// Define a message that contains a time value
type TimeResponse struct {
	// Ticks value representing the time in question.
	Current              int64    `protobuf:"varint,1,opt,name=current,proto3" json:"current,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeResponse) Reset()         { *m = TimeResponse{} }
func (m *TimeResponse) String() string { return proto.CompactTextString(m) }
func (*TimeResponse) ProtoMessage()    {}
func (*TimeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a47a4dd6ded36602, []int{2}
}

func (m *TimeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TimeResponse.Unmarshal(m, b)
}
func (m *TimeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TimeResponse.Marshal(b, m, deterministic)
}
func (m *TimeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeResponse.Merge(m, src)
}
func (m *TimeResponse) XXX_Size() int {
	return xxx_messageInfo_TimeResponse.Size(m)
}
func (m *TimeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TimeResponse proto.InternalMessageInfo

func (m *TimeResponse) GetCurrent() int64 {
	if m != nil {
		return m.Current
	}
	return 0
}

func init() {
	proto.RegisterEnum("stepper.StepperPolicy", StepperPolicy_name, StepperPolicy_value)
	proto.RegisterType((*PolicyRequest)(nil), "stepper.PolicyRequest")
	proto.RegisterType((*DelayRequest)(nil), "stepper.DelayRequest")
	proto.RegisterType((*TimeResponse)(nil), "stepper.TimeResponse")
}

func init() { proto.RegisterFile("Stepper/stepper.proto", fileDescriptor_a47a4dd6ded36602) }

var fileDescriptor_a47a4dd6ded36602 = []byte{
	// 340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x51, 0x4f, 0x4f, 0xfa, 0x40,
	0x14, 0xfc, 0x95, 0xfe, 0x6c, 0xf5, 0x01, 0xa6, 0xd9, 0x04, 0x82, 0x98, 0x18, 0xc2, 0x89, 0x78,
	0x28, 0x09, 0xfe, 0xb9, 0x78, 0xd0, 0x18, 0x3c, 0x98, 0x08, 0x31, 0xc5, 0xc4, 0xf3, 0x02, 0x4f,
	0x52, 0x53, 0xba, 0xeb, 0xfe, 0xd1, 0x70, 0xf3, 0xfb, 0xfa, 0x25, 0x4c, 0xb7, 0x5b, 0xb0, 0x9a,
	0x9e, 0xda, 0xf7, 0x66, 0xde, 0xcc, 0x74, 0x0a, 0xad, 0x99, 0x42, 0xce, 0x51, 0x0c, 0x65, 0xfe,
	0x0c, 0xb9, 0x60, 0x8a, 0x11, 0xdf, 0x8e, 0xdd, 0xe3, 0x15, 0x63, 0xab, 0x04, 0x87, 0x66, 0x3d,
	0xd7, 0x2f, 0x43, 0x5c, 0x73, 0xb5, 0xc9, 0x59, 0xdd, 0x93, 0xdf, 0xe0, 0x52, 0x0b, 0xaa, 0x62,
	0x96, 0xe6, 0x78, 0xff, 0xd3, 0x81, 0xe6, 0x23, 0x4b, 0xe2, 0xc5, 0x26, 0xc2, 0x37, 0x8d, 0x52,
	0x91, 0x10, 0x3c, 0x6e, 0x16, 0x1d, 0xa7, 0xe7, 0x0c, 0x0e, 0x47, 0xed, 0xb0, 0xf0, 0xb5, 0x39,
	0x2c, 0xdd, 0xb2, 0xc8, 0x35, 0x34, 0xd7, 0x48, 0xa5, 0x16, 0xb8, 0x1c, 0x63, 0x42, 0x37, 0x9d,
	0x5a, 0xcf, 0x19, 0xd4, 0x47, 0x47, 0x61, 0xee, 0x1c, 0x16, 0xce, 0xe1, 0xd8, 0x3a, 0x47, 0x65,
	0x7e, 0xff, 0x06, 0x1a, 0xe6, 0xa5, 0x08, 0xd0, 0x01, 0x9f, 0xaa, 0x07, 0xa4, 0x52, 0x99, 0x04,
	0x6e, 0x54, 0x8c, 0xa4, 0x0d, 0xde, 0x6b, 0xac, 0x14, 0x0a, 0xe3, 0xe1, 0x46, 0x76, 0xea, 0x0f,
	0xa0, 0xf1, 0x14, 0xaf, 0x31, 0x42, 0xc9, 0x59, 0x2a, 0x31, 0x53, 0x58, 0x68, 0x21, 0x30, 0xdd,
	0x2a, 0xd8, 0xf1, 0xf4, 0x16, 0x9a, 0xa5, 0xaf, 0x20, 0x75, 0xf0, 0xef, 0xd3, 0x77, 0x9a, 0xc4,
	0xcb, 0xe0, 0x1f, 0x01, 0xf0, 0xa6, 0xec, 0x99, 0xc6, 0x2a, 0x70, 0x48, 0x03, 0xf6, 0x27, 0x36,
	0x66, 0x50, 0xcb, 0x90, 0x09, 0x4d, 0x35, 0x4d, 0x02, 0x77, 0xf4, 0xe5, 0x80, 0x6f, 0x45, 0xc8,
	0x15, 0x1c, 0xcc, 0x50, 0x59, 0xad, 0x5d, 0x53, 0xa5, 0x46, 0xbb, 0xed, 0x3f, 0x55, 0xdc, 0x65,
	0x7f, 0x88, 0x5c, 0xc2, 0xff, 0x4c, 0x87, 0x54, 0xe0, 0x95, 0x77, 0xe7, 0xe0, 0x4e, 0xd9, 0x47,
	0xe5, 0x59, 0x6b, 0x1b, 0xa3, 0x54, 0xca, 0x05, 0xec, 0x99, 0x9a, 0xc9, 0x0e, 0xff, 0x59, 0x7b,
	0xc5, 0xd9, 0xdc, 0x33, 0xea, 0x67, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x35, 0xf8, 0x3f, 0x23,
	0x86, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StepperClient is the client API for Stepper service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StepperClient interface {
	// Set the stepper's policy governing the rate and conditions
	// for the simulated time to move forward.
	SetPolicy(ctx context.Context, in *PolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	// When the stepper policy is for manual single-stepping, this
	// function forces a single step forward in simulated time.
	Step(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error)
	// Get the current simulated time.
	Now(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TimeResponse, error)
	// Delay the simulated time by a specified amount +/- an allowed variance.
	// Do not return until that new time is current.
	Delay(ctx context.Context, in *DelayRequest, opts ...grpc.CallOption) (*TimeResponse, error)
}

type stepperClient struct {
	cc *grpc.ClientConn
}

func NewStepperClient(cc *grpc.ClientConn) StepperClient {
	return &stepperClient{cc}
}

func (c *stepperClient) SetPolicy(ctx context.Context, in *PolicyRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/stepper.Stepper/SetPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepperClient) Step(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/stepper.Stepper/Step", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepperClient) Now(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := c.cc.Invoke(ctx, "/stepper.Stepper/Now", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepperClient) Delay(ctx context.Context, in *DelayRequest, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := c.cc.Invoke(ctx, "/stepper.Stepper/Delay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StepperServer is the server API for Stepper service.
type StepperServer interface {
	// Set the stepper's policy governing the rate and conditions
	// for the simulated time to move forward.
	SetPolicy(context.Context, *PolicyRequest) (*empty.Empty, error)
	// When the stepper policy is for manual single-stepping, this
	// function forces a single step forward in simulated time.
	Step(context.Context, *empty.Empty) (*empty.Empty, error)
	// Get the current simulated time.
	Now(context.Context, *empty.Empty) (*TimeResponse, error)
	// Delay the simulated time by a specified amount +/- an allowed variance.
	// Do not return until that new time is current.
	Delay(context.Context, *DelayRequest) (*TimeResponse, error)
}

// UnimplementedStepperServer can be embedded to have forward compatible implementations.
type UnimplementedStepperServer struct {
}

func (*UnimplementedStepperServer) SetPolicy(ctx context.Context, req *PolicyRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPolicy not implemented")
}
func (*UnimplementedStepperServer) Step(ctx context.Context, req *empty.Empty) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Step not implemented")
}
func (*UnimplementedStepperServer) Now(ctx context.Context, req *empty.Empty) (*TimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Now not implemented")
}
func (*UnimplementedStepperServer) Delay(ctx context.Context, req *DelayRequest) (*TimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delay not implemented")
}

func RegisterStepperServer(s *grpc.Server, srv StepperServer) {
	s.RegisterService(&_Stepper_serviceDesc, srv)
}

func _Stepper_SetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepperServer).SetPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stepper.Stepper/SetPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepperServer).SetPolicy(ctx, req.(*PolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stepper_Step_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepperServer).Step(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stepper.Stepper/Step",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepperServer).Step(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stepper_Now_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepperServer).Now(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stepper.Stepper/Now",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepperServer).Now(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stepper_Delay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepperServer).Delay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stepper.Stepper/Delay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepperServer).Delay(ctx, req.(*DelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Stepper_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stepper.Stepper",
	HandlerType: (*StepperServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetPolicy",
			Handler:    _Stepper_SetPolicy_Handler,
		},
		{
			MethodName: "Step",
			Handler:    _Stepper_Step_Handler,
		},
		{
			MethodName: "Now",
			Handler:    _Stepper_Now_Handler,
		},
		{
			MethodName: "Delay",
			Handler:    _Stepper_Delay_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "Stepper/stepper.proto",
}
